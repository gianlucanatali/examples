
AKS_BASE_MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))
AKS_BASE_MKFILE_DIR := $(dir $(AKS_BASE_MKFILE_PATH))

include $(AKS_BASE_MKFILE_DIR)../common/Makefile

#AZURE_ACCOUNT_ID ?= $(shell gcloud config list --format 'value(core.project)')

AKS_BASE_CLUSTER_ID ?= cp-examples-operator-$(USER)
AKS_BASE_REGION ?= centralus
AKS_BASE_ZONE ?= 1
AKS_BASE_SUBNET ?= default
AKS_BASE_CLUSTER_VERSION ?= 1.17.7
AKS_BASE_MACHINE_TYPE ?= Standard_D4_v3
AKS_BASE_IMAGE_TYPE ?= COS
AKS_BASE_DISK_TYPE ?= pd-standard
AKS_BASE_DISK_SIZE ?= 100
AKS_BASE_NUM_NODES ?= 3

AKS_BASE_ZOOKEEPER_REPLICAS ?= 1
AKS_BASE_KAFKA_REPLICAS ?= 1
AKS_BASE_CONNECT_REPLICAS ?= 1
AKS_BASE_SCHEMA_REGISTRY_REPLICAS ?= 1

AKS_BASE_KUBECTL_CONTEXT ?= aks_$(AZ_RESOURCE_GROUP)_$(AKS_BASE_REGION)_$(AKS_BASE_CLUSTER_ID)
AKS_BASE_KUBECTL_NAMESPACE ?= operator

AKS_BASE_ADDITIONAL_HELM_FLAGS ?=

AKS_BASE_SKIP_CLICKS ?=
AKS_BASE_SKIP_CLIENT_CONSOLE ?=
 
AKS_BASE_HELM_COMMON_FLAGS := --wait --timeout=5m -f $(AKS_BASE_MKFILE_DIR)cfg/values.yaml --set global.initContainer.image.tag=$(OPERATOR_CP_IMAGE_TAG) --set global.provider.region=$(AKS_BASE_REGION) --set global.provider.kubernetes.deployment.zones={$(AKS_BASE_REGION)-$(AKS_BASE_ZONE)} $(AKS_BASE_ADDITIONAL_HELM_FLAGS)

aks-check-dependencies: check-dependencies
	@$(call check-var-defined,AZ_RESOURCE_GROUP)
	@$(call check-dependency,az)
	@$(call echo_pass,aks-base dependencies verified)

aks-create-cluster: aks-check-dependencies ## Creates a AKS cluster based on the values of the AKS_* variables.  WARN: This will incur charges in your Azure account.
	@$(call echo_stdout_header,Create AKS cluster expect 5 mins)	
	az aks create --only-show-errors --resource-group $(AZ_RESOURCE_GROUP) --name $(AKS_BASE_CLUSTER_ID) --location $(AKS_BASE_REGION) --zones $(AKS_BASE_ZONE) --kubernetes-version $(AKS_BASE_CLUSTER_VERSION) --node-vm-size $(AKS_BASE_MACHINE_TYPE) --node-osdisk-size $(AKS_BASE_DISK_SIZE) --node-count $(AKS_BASE_NUM_NODES)  --enable-addons monitoring --generate-ssh-keys  -o yaml
	az aks get-credentials --only-show-errors --resource-group $(AZ_RESOURCE_GROUP) --name $(AKS_BASE_CLUSTER_ID) --context $(AKS_BASE_KUBECTL_CONTEXT)
	@$(call echo_stdout_footer_pass,AKS Cluster Created)

aks-destroy-cluster: aks-check-dependencies ## Destroys the AKS cluster built from the aks-create-cluster command 
	@$(call echo_stdout_header,Delete AKS cluster)
	az aks delete --name $(AKS_BASE_CLUSTER_ID) --resource-group $(AZ_RESOURCE_GROUP) --yes
	kubectl config unset contexts.$(AKS_BASE_KUBECTL_CONTEXT)
	@$(call echo_stdout_footer_pass,AKS Cluster Deleted)

aks-base-ensure-namespace:
	@$(call echo_stdout_header,ensuring namespace is avaiable)	
	-kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) apply -f $(AKS_BASE_MKFILE_DIR)cfg/operator-namespace.json
	@$(call echo_stdout_footer_pass,namespace ready)

aks-base-validate: aks-check-dependencies init
	@echo
	@make --no-print-directory aks-base-ensure-namespace
	@$(call echo_pass,aks-base demo validation complete)

###### OPERATOR MANAGEMENT ######
aks-base-deploy-operator: #_ Deploys the Confluent Operator into the configured k8s cluster 
	@$(call echo_stdout_header,deploy operator)	
	helm upgrade --install --namespace $(AKS_BASE_KUBECTL_NAMESPACE) $(AKS_BASE_HELM_COMMON_FLAGS) --set operator.enabled=true operator $(OPERATOR_PATH)helm/confluent-operator
	@$(call echo_stdout_footer_pass,operator deployed)

aks-base-wait-for-operator: #_ Waits until the Confluent Operator rollout status is complete
	@$(call echo_stdout_header,wait for operator)	
	kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) rollout status deployment/cc-operator
	@$(call echo_stdout_footer_pass,operator ready)

aks-base-destroy-operator: #_ Destroy the operator deployment on the configured k8s cluster
	@$(call echo_stdout_header,destroy operator)
	-helm delete operator --namespace $(AKS_BASE_KUBECTL_NAMESPACE)
	@$(call echo_stdout_footer_pass,operator destroyed)

aks-base-wait-for-operator-destruction: #j Will wait until the Confluent Operator & Manager are destroyed
	@$(call echo_stdout_header,ensure operator destroyed)
	-kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) wait --timeout=60s --for=delete deployment/cc-operator
	@$(call echo_stdout_footer_pass,operator gone)
#################################

###### ZOOKEEPER MANAGEMENT ######
aks-base-deploy-zookeeper: #_ Deploys Zookeeper into the configured k8s cluster
	@$(call echo_stdout_header,Deploy Zookeeper)
	helm upgrade --install --namespace $(AKS_BASE_KUBECTL_NAMESPACE) $(AKS_BASE_HELM_COMMON_FLAGS) --set zookeeper.image.tag=$(OPERATOR_CP_IMAGE_TAG) --set zookeeper.replicas=$(AKS_BASE_ZOOKEEPER_REPLICAS) --set zookeeper.enabled=true zookeeper $(OPERATOR_PATH)helm/confluent-operator
	@$(call echo_stdout_footer_pass,Zookeeper deployed)

aks-base-wait-for-zookeeper: #_ Waits until the Zookeeper rollout is complete
	@$(call echo_stdout_header,Wait for Zookeper)
	source $(COMMON_MKFILE_DIR)bin/retry.sh; retry 15 kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n operator get sts zookeeper 
	kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) rollout status statefulset/zookeeper
	@$(call echo_stdout_footer_pass,Zookeeper ready)

aks-base-destroy-zookeeper: #_ Purge the Zookeeper package 
	@$(call echo_stdout_header,Purge the Zookeeper package)
	-helm delete zookeeper --namespace $(AKS_BASE_KUBECTL_NAMESPACE)
# There are currently some issues with ZK cleanup in the Helm packages, for now i'm helping along with extra delete commands
	-kubectl -n $(AKS_BASE_KUBECTL_NAMESPACE) delete sts/zookeeper
	-kubectl -n operator delete service/zookeeper;kubectl -n $(AKS_BASE_KUBECTL_NAMESPACE) delete service/zookeeper-0-internal;
	-kubectl -n operator delete service/zookeeper;kubectl -n $(AKS_BASE_KUBECTL_NAMESPACE) delete service/zookeeper-1-internal;
	-kubectl -n operator delete service/zookeeper;kubectl -n $(AKS_BASE_KUBECTL_NAMESPACE) delete service/zookeeper-2-internal;
	@$(call echo_stdout_footer_pass,Zookeeper purged)

aks-base-wait-for-zookeeper-destruction: #_ Waits until the Zookeper cluster is destroyed
	@$(call echo_stdout_header,Ensure Zookeeper destroyed)
	-kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) wait --timeout=60s --for=delete statefulset/zookeeper
	@$(call echo_stdout_footer_pass,Zookeeper gone)
#################################

######### KAFKA MANAGEMENT ######
aks-base-deploy-kafka: #_ Deploys Kafka into the configured k8s cluster
	@$(call echo_stdout_header,deploy kafka) 
	helm upgrade --install --namespace $(AKS_BASE_KUBECTL_NAMESPACE) $(AKS_BASE_HELM_COMMON_FLAGS) --set kafka.image.tag=$(OPERATOR_CP_IMAGE_TAG) --set kafka.replicas=$(AKS_BASE_KAFKA_REPLICAS) --set kafka.enabled=true kafka $(OPERATOR_PATH)helm/confluent-operator
	@$(call echo_stdout_footer_pass,Kafka deployed)

aks-base-wait-for-kafka: #_ Waits until the Kafka rollout is complete
	@$(call echo_stdout_header,Wait for Kafka)
	source $(COMMON_MKFILE_DIR)bin/retry.sh; retry 15 kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) get sts kafka 
	kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) rollout status statefulset/kafka
	@$(call echo_stdout_footer_pass,Kafka ready)

aks-base-destroy-kafka: #_ Purge the Kafka package 
	@$(call echo_stdout_header,Purge the Kafka package)
	-helm delete kafka --namespace $(AKS_BASE_KUBECTL_NAMESPACE)
	@$(call echo_stdout_footer_pass,Kafka purged)

aks-base-wait-for-kafka-destruction: #_ Waits until the Kafka cluster is destroyed
	@$(call echo_stdout_header,Ensure Kafka destroyed)
	-kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) wait --timeout=60s --for=delete statefulset/kafka
	@$(call echo_stdout_footer_pass,Kafka gone)
#################################

### SCHEMA REGISTRY MANAGEMENT ##
aks-base-deploy-schemaregistry: #_ Deploys the Schmea Registry to the configured k8s cluster
	@$(call echo_stdout_header,Deploy Schema Registry)
	helm upgrade --install --namespace $(AKS_BASE_KUBECTL_NAMESPACE) $(AKS_BASE_HELM_COMMON_FLAGS) --set schemaregistry.image.tag=$(OPERATOR_CP_IMAGE_TAG) --set schemaregistry.enabled=true --set schemaregistry.replicas=$(AKS_BASE_SCHEMA_REGISTRY_REPLICAS) schemaregistry $(OPERATOR_PATH)helm/confluent-operator
	@$(call echo_stdout_footer_pass,Schema Registry deployed)

aks-base-wait-for-schemaregistry: #_ Waits until the Schema Registry rollout is complete
	@$(call echo_stdout_header,Wait for Schema Registry)
	source $(COMMON_MKFILE_DIR)bin/retry.sh; retry 15 kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) get sts schemaregistry
	kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) rollout status statefulset/schemaregistry
	@$(call echo_stdout_footer_pass,Schema Registry ready)

aks-base-destroy-schemaregistry: #_ Purge the Schema Registry package
	@$(call echo_stdout_header,Purge the Schema Registry package)
	-helm delete schemaregistry --namespace $(AKS_BASE_KUBECTL_NAMESPACE)
	@$(call echo_stdout_footer_pass,Schema Registry purged) 

aks-base-wait-for-schemaregistry-destruction: #_ Waits until the Schema Registry is destroyed
	@$(call echo_stdout_header,Ensure Schema Registry destroyed)
	-kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) wait --timeout=60s --for=delete statefulset/schemaregistry
	@$(call echo_stdout_footer_pass,Schema Registry gone)
#################################

##### CONNECT  MANAGEMENT #######
aks-base-deploy-connect: #_ Deploys Kafka Connect to the configured k8s cluster
	@$(call echo_stdout_header,Deploy Kafka Connect)
	helm upgrade --install --namespace $(AKS_BASE_KUBECTL_NAMESPACE) $(AKS_BASE_HELM_COMMON_FLAGS) --set connect.image.tag=$(OPERATOR_KAFKA_CONNECT_DATAGEN_IMAGE_TAG) --set connect.enabled=true --set connect.replicas=$(AKS_BASE_CONNECT_REPLICAS) connect $(OPERATOR_PATH)helm/confluent-operator
	@$(call echo_stdout_footer_pass,Kafka Connect deployed)

aks-base-wait-for-connect: #_ Waits until the Kafka Connect rollout is complete
	@$(call echo_stdout_header,Wait for Kafka Connect)
	source $(COMMON_MKFILE_DIR)bin/retry.sh; retry 15 kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n operator get sts connectors
	kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) rollout status statefulset/connectors
	@$(call echo_stdout_footer_pass,Kafka Connect ready)

aks-base-destroy-connect: #_ Purge the Kafka Connect package 
	@$(call echo_stdout_header,Purge the Kafka Connect package)
	-helm delete connect --namespace $(AKS_BASE_KUBECTL_NAMESPACE)
	@$(call echo_stdout_footer_pass,Kafka Connect purged)

aks-base-wait-for-connect-destruction: #_ Waits until Kafka Connect is destroyed
	@$(call echo_stdout_header,Ensure Kafka Connect destroyed)
	-kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) wait --timeout=60s --for=delete statefulset/connectors
	@$(call echo_stdout_footer_pass,Kafka Connect gone)
#################################

### CONTROL CENTER MANAGEMENT ####
aks-base-deploy-controlcenter: #_ Deploys Confluent Control Center to the configured k8s cluster
	@$(call echo_stdout_header,Deploy Control Center)
	helm upgrade --install --namespace $(AKS_BASE_KUBECTL_NAMESPACE) $(AKS_BASE_HELM_COMMON_FLAGS) --set controlcenter.image.tag=$(OPERATOR_CP_IMAGE_TAG) --set controlcenter.enabled=true controlcenter $(OPERATOR_PATH)helm/confluent-operator
	@$(call echo_stdout_footer_pass,Control Center deployed)

aks-base-wait-for-controlcenter: #_ Waits until the Control Center rollout is complete
	@$(call echo_stdout_header,Wait for Control Center)
	source $(COMMON_MKFILE_DIR)bin/retry.sh; retry 15 kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) get sts controlcenter 
	kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) rollout status statefulset/controlcenter
	@$(call echo_stdout_footer_pass,Control Center ready)

aks-base-destroy-controlcenter: #_ Purge the Control Center package 
	@$(call echo_stdout_header,Purge the Control Center package)
	-helm delete controlcenter --namespace $(AKS_BASE_KUBECTL_NAMESPACE)
	@$(call echo_stdout_footer_pass,Control Center purged)

aks-base-wait-for-controlcenter-destruction: #_ Waits until Control Center is destroyed
	@$(call echo_stdout_header,Ensure Control Center destroyed)
	-kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) wait --timeout=60s --for=delete statefulset/controlcenter
	@$(call echo_stdout_footer_pass,Control Center gone)
#################################

### CLICKS DATA GEN CONNECTOR ###
aks-base-deploy-clicks-connector-config: #_ Deploys configuration for a connector that generates sample click data
	@$(call echo_stdout_header,Deploy clicks datagen connector config)
	kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) apply -f $(AKS_BASE_MKFILE_DIR)cfg/clicks-datagen-connector-configmap.yaml
	@$(call echo_stdout_footer_pass,clicks datagen connector config deployed)

aks-base-destroy-clicks-connector-deploy-job: #_ Destroys the job that deployed the sample data generator connector
	@$(call echo_stdout_header,destory Deploy clicks datagen connector job)
	-kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) delete jobs/clicks-datagen-connector-deploy ## name dependnecy in file, required unless/until TTL works across all k8s configurations
	@$(call echo_stdout_footer_pass,clicks datagen connector job destroyed)

aks-base-deploy-clicks-connector: aks-base-deploy-clicks-connector-config aks-base-destroy-clicks-connector-deploy-job #_ Deploys a connector that generates sample click data
	@$(call echo_stdout_header,Deploy clicks datagen connector)
	kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) apply -f $(AKS_BASE_MKFILE_DIR)cfg/clicks-datagen-connector-deploy-job.yaml
	@$(call echo_stdout_footer_pass,clicks datagen connector deployed)
#################################

### STOCK TRADES DATA GEN CONNECTOR ###
aks-base-deploy-stock-trades-connector-config: #_ Deploys configuration for a connector that generates sample stock trade data
	@$(call echo_stdout_header,Deploy stock trades datagen connector config)
	kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) apply -f $(AKS_BASE_MKFILE_DIR)cfg/stock-trades-datagen-connector-configmap.yaml
	@$(call echo_stdout_footer_pass,stock trades datagen connector config deployed)

aks-base-destroy-stock-trades-connector: #_ Destroys the deploy job and configuration for the sample stock trades data generator
	@$(call echo_stdout_header,destory Deploy stock trades datagen connector)
	-make --no-print-directory aks-base-destroy-stock-trades-connector-deploy-job
	-kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) delete configmap/stock-trades-datagen-connector
	@$(call echo_stdout_footer_pass,stock trades datagen connector destroyed)

aks-base-destroy-stock-trades-connector-deploy-job: #_ Destroys the job that deployed the sample stock trades data generator connector
	@$(call echo_stdout_header,destory Deploy stock trades datagen connector job)
	-kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) delete jobs/stock-trades-datagen-connector-deploy ## name dependnecy in file, required unless/until TTL works across all k8s configurations
	@$(call echo_stdout_footer_pass,stock trades datagen connector job destroyed)

aks-base-deploy-stock-trades-connector: aks-base-deploy-stock-trades-connector-config aks-base-destroy-stock-trades-connector-deploy-job #_ Deploys a connector that generates sample stock trades data
	@$(call echo_stdout_header,Deploy stock trades datagen connector)
	kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) apply -f $(AKS_BASE_MKFILE_DIR)cfg/stock-trades-datagen-connector-deploy-job.yaml
	@$(call echo_stdout_footer_pass,stock trades datagen connector deployed)
#################################

########## CLIENT SECRETS #######
aks-base-deploy-client-secrets:
	@$(call echo_stdout_header,Deploy client secrets)
	kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) apply -f $(AKS_BASE_MKFILE_DIR)cfg/kafka-client-secrets.yaml
	@$(call echo_stdout_footer_pass,client secrets deployed)

aks-base-destroy-client-secrets:
	@$(call echo_stdout_header,Delete client secrets)
	-kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) delete secret kafka-client.properties
	@$(call echo_stdout_footer_pass,client secrets destroyed)
#################################

########## CLIENT CONSOLE #######
aks-base-deploy-client-console:
	@$(call echo_stdout_header,Deploy client-console)
	kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) apply -f $(AKS_BASE_MKFILE_DIR)cfg/client-console-pod.yaml
	@$(call echo_stdout_footer_pass,client-console deployed)

aks-base-destroy-client-console:
	@$(call echo_stdout_header,Delete client-console)
	-kubectl --context $(AKS_BASE_KUBECTL_CONTEXT) -n $(AKS_BASE_KUBECTL_NAMESPACE) delete pod client-console 
	@$(call echo_stdout_footer_pass,client-console destroyed)
#################################

aks-base-demo: aks-base-validate
	@make --no-print-directory aks-base-deploy-operator
	@make --no-print-directory aks-base-wait-for-operator
	@make --no-print-directory aks-base-deploy-zookeeper
	@make --no-print-directory aks-base-wait-for-zookeeper
	@make --no-print-directory aks-base-deploy-kafka
	@make --no-print-directory aks-base-wait-for-kafka
	@make --no-print-directory aks-base-deploy-client-secrets
ifeq ($(strip $(AKS_BASE_SKIP_CLIENT_CONSOLE)),)
	@make --no-print-directory aks-base-deploy-client-console
endif
	@make --no-print-directory aks-base-deploy-schemaregistry
	@make --no-print-directory aks-base-wait-for-schemaregistry
	@make --no-print-directory aks-base-deploy-connect
	@make --no-print-directory aks-base-wait-for-connect
ifeq ($(strip $(AKS_BASE_SKIP_CLICKS)),)
	@make --no-print-directory aks-base-deploy-clicks-connector
endif
	@make --no-print-directory aks-base-deploy-controlcenter
	@make --no-print-directory aks-base-wait-for-controlcenter
	@echo
	@$(call echo_pass,AKS Base Demo running)

aks-base-destroy-demo: aks-base-validate
	@make --no-print-directory aks-base-destroy-client-console
	@make --no-print-directory aks-base-destroy-client-secrets
	@make --no-print-directory aks-base-destroy-clicks-connector-deploy-job
	@make --no-print-directory aks-base-destroy-controlcenter
	@make --no-print-directory aks-base-wait-for-controlcenter-destruction
	@make --no-print-directory aks-base-destroy-connect
	@make --no-print-directory aks-base-wait-for-connect-destruction
	@make --no-print-directory aks-base-destroy-schemaregistry
	@make --no-print-directory aks-base-wait-for-schemaregistry-destruction
	@make --no-print-directory aks-base-destroy-kafka
	@make --no-print-directory aks-base-wait-for-kafka-destruction
	@make --no-print-directory aks-base-destroy-zookeeper
	@make --no-print-directory aks-base-wait-for-zookeeper-destruction
	@make --no-print-directory aks-base-destroy-operator
	@make --no-print-directory aks-base-wait-for-operator-destruction
	@echo
	@$(call echo_pass,AKS Base Demo destroyed)
